import { inspect } from 'util';

const assertMiddleware = (middleware) => {
    if (typeof middleware !== 'function') {
        throw new TypeError('Middleware must be composed of functions!');
    }
};
const assertMiddlewares = (middlewares) => (middlewares.forEach(assertMiddleware));
const noopNext = async () => { };
const skipMiddleware = (context, next) => next();
const stopMiddleware = async (context, next) => { };

function composeChain(middlewares) {
    assertMiddlewares(middlewares);
    return (context) => {
        let lastIndex = -1;
        const nextDispatch = async (index) => {
            if (index <= lastIndex) {
                throw new Error('next() called multiple times');
            }
            lastIndex = index;
            const middleware = middlewares[index];
            if (!middleware) {
                return;
            }
            await middleware(context, () => (nextDispatch(index + 1)));
        };
        return nextDispatch(0);
    };
}
function compose(middlewares, next) {
    return composeChain([
        ...middlewares,
        next
    ]);
}
function composeWithPayload(middlewares, next) {
    assertMiddlewares(middlewares);
    return (context, payload) => {
        let lastIndex = -1;
        const nextDispatch = async (index) => {
            if (index <= lastIndex) {
                throw new Error('next() called multiple times');
            }
            lastIndex = index;
            const middleware = middlewares[index];
            if (!middleware) {
                await next(context, payload);
                return payload;
            }
            await middleware(context, () => (nextDispatch(index + 1)));
            return payload;
        };
        return nextDispatch(0);
    };
}

class MiddlewareStatus {
    /**
     * Constructor
     */
    constructor(middlewares) {
        this.middlewares = [];
        this.stack = async () => ({
            finished: true
        });
        if (middlewares === undefined) {
            return;
        }
        this.use(middlewares);
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns count middleware in chain
     */
    get length() {
        return this.middlewares.length;
    }
    /**
     * Adds middlewares
     */
    use(middlewares) {
        if (!Array.isArray(middlewares)) {
            middlewares = [middlewares];
        }
        assertMiddlewares(middlewares);
        this.middlewares.push(...middlewares);
        this.stack = composeWithPayload(this.middlewares, async (context, payload) => {
            payload.finished = true;
        });
        return this;
    }
    /**
     * Launches the middleware chain
     */
    run(context) {
        return this.stack(context, {
            finished: false,
        });
    }
    /**
     * Custom inspect object
     */
    // tslint:disable-next-line:function-name
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        return `${options.stylize(name, 'special')}`
            + `{ length: ${options.stylize(this.length, 'number')} }`;
    }
}

const getBranchMiddleware = (condition, trueMiddleware, falseMiddleware) => {
    if (typeof condition !== 'function') {
        return condition
            ? trueMiddleware
            : falseMiddleware;
    }
    return async (context, next) => (await condition(context)
        ? trueMiddleware(context, next)
        : falseMiddleware(context, next));
};
const getOptionalMiddleware = (condition, optionalMiddleware) => (getBranchMiddleware(condition, optionalMiddleware, skipMiddleware));
const getFilterMiddleware = (condition, filterMiddleware) => (getBranchMiddleware(condition, filterMiddleware, stopMiddleware));
const getBeforeMiddleware = (beforeMiddleware, middleware) => (async (context, next) => {
    let called = false;
    await beforeMiddleware(context, async () => {
        called = true;
    });
    if (called) {
        await middleware(context, next);
    }
});
const getAfterMiddleware = (middleware, afterMiddleware) => (async (context, next) => {
    let called = false;
    await middleware(context, async () => {
        called = true;
    });
    if (called) {
        await afterMiddleware(context, next);
    }
});

export default MiddlewareStatus;
export { MiddlewareStatus, skipMiddleware, stopMiddleware, noopNext, composeChain, compose, composeWithPayload, getBranchMiddleware, getOptionalMiddleware, getFilterMiddleware, getBeforeMiddleware, getAfterMiddleware };
